(set-logic QF_LIA)

; Before operator from past LTL
(define-system Before 
  :input ((b Bool)) 
  :output ((before_b Bool))
  :init (= before_b false)
  :trans (= before_b' b)
)

; Historically operator from past LTL
(define-system Historically 
  :input ((b Bool)) 
  :output ((hist_b Bool))
  :init (= hist_b b) 
  :trans (= hist_b' (and b' hist_b))
)

; (Count b) counts number of times b has been true so far
(define-system Count 
    :input ((b Bool)) 
    :output ((c Int))
    :init (= c (ite b 1 0)) 
    :trans (= c' (+ c (ite b 0 1)))
)

(define-system NonDetArbiter
 :input ( (r1 Bool) (r2 Bool) )
 :output ( (g1 Bool) (g2 Bool) )
 :local ( (s Bool) )
 :inv (and
  (=> (and (not r1) (not r2))
      (and (not g1) (not g2)))
  (=> (and r1 (not r2))
      (and g1 (not g2)))
  (=> (and (not r1) r2)
      (and (not g1) g2))
  (=> (and r1 r2)
      ; the unconstrained value of `s` is used as non-deterministic choice
      (ite s (and g1 (not g2))
        (and (not g1) g2)))
  )
)

(define-system Monitor 
 :input ((r1 Bool) (r2 Bool)) 
 :output ((g1 Bool) (g2 Bool))  
 :local ((a1 Bool) (a2 Bool) (b Bool) (h1 Bool) (h2 Bool) (bf Bool) (c1 Int))
 :subsys (A (NonDetArbiter r1 r2 g1 g2))
 :subsys (H1 (Historically a1 h1))
 :subsys (H2 (Historically a2 h2))
 :subsys (C (Count g1 c1))
 :subsys (B (Before b bf))
 :inv (and
   ; a1 <=> no requests
   (= a1 (and (not r1) (not r2)))
   ; a2 <=> no grants
   (= a2 (and (not g1) (not g2)))
   ; b <=> 1 is 3
   (= b (= c1 3))
 )
)

(check-system Monitor 
 :input ((r1 Bool) (r2 Bool)) 
 :output ((g1 Bool) (g2 Bool))
 :local ((a1 Bool) (a2 Bool) (b Bool) (h1 Bool) (h2 Bool) 
         (bf Bool) (c1 Int))
 ; no concurrent requests
 :assumption (A (not (and r1 r2))) 
 ; neg of: if there have been no requests, there have been no grants 
 :reachable (P1 (not (=> h1 h2))) 
 ; neg of: a request was granted at most 3 times
 :reachable (P2 (not (=> bf (not g1)))) 
 :query (Q1 (A P1))
 :query (Q2 (A P2))
)
